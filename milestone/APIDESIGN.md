|Action | Inputs/Data | Pre conditions | post conditions | API Endpoint |
| -----| -----------| -----------------| ---------------| ------------- |
|User creates an account | <ul><li> Username (string) (player_id)</li><li> Password (string)</li><li> Avatar_id</li></ul> | <ul><li>username cannot contain special characters (letters and numbers only) </li><li>Password cannot contain special characters (letters and numbers only) </li><li>Username must be unique (no duplicates in the database and no whitespace) </li><li>Password length needs to be longer than 4 </li></ul>|<ul><li>Saves the new user into a database (username, password, avatar) </li><li>Encryption of password</li><li> Username becomes player_id</li> </li></ul> | POST /login/create |
| User logs in | <ul><li>Username (string) (player_id)</li><li>Password (string)</li><li>isAuthenticated = False</li></ul> | <li>player_id exists in the database (IS NOT NULL)</li> | isAuthenticated returns true if username and password matches in database | POST /login |
| User in waiting lobby | <ul><li>Chat message (string) </li><li>Player_id</li><li>left_game (bool)</li><li>Player_count</li><li>Game_id</li><li>Avatar_id </li></ul> | <li>isAuthenticated is True</li> <li>If player_count of game_id is not full, user can join, incrementing player_count</li><li>If game_id is still active, and left_game is True, then a user can join a previously left game (with the same cards)</li><li>Maybe a timeout that starts the game automatically for players? A waiting time </li> | <li>Chat log is updated when a user writes a message</li><li>Each player_id has ability to send and receive messages globally</li><li>Player_id and avatar_id can be viewable on the screen</li> | POST /lobby |
| User creates a game |  <li>Player_id<li>Game_title<li>Player_count<li>Avatar_id |  |<li>New game is created with a game_id<li>Each player_id is redirected to the game room <li>Each player_id is added to a game_id<li>Player_id and avatar_id is visible to other player_id<li> | POST/game/create (game_id, player_count) |
| User starts the game | <li>Player_id </li><li>Game_id</li><li>Card object</li><li>Card_id</li><li>Deck object</li><li>Hand object</li><li>Turn_order</li><li>Score</li><li>Chat message (string)</li><li>Avatar_id</li> | <li>Player_id is successfully added to a game_id</li> | <li>Deck is shuffled randomly</li><li>Each user score is set to 0</li><li>Each player_id receives 7 cards into their hand from the deck</li><li>Top card of deck is placed as first card of game</li><li>Count of deck is decreased by 7*player_count + 1</li><li>Each player_id is assigned with a turn_order</li><li>Deck object and hand object is not visible by other player_id</li><li>Hand object instance is assigned to each player_id?</li><li>Chat log is updated when a user writes a message</li><li>Each player_id should have ability to send and receive messages</li><li>Player_id and avatar_id is visible to other player_id</li> | POST/game/:game_id/start (game_id, player_count) |
| User’s turn to play |<li>Player_id</li><li>Game_id</li><li>Card object</li><li>Card_id</li><li>Deck object</li><li>Hand object</li><li>Turn_order</li><li>Score</li><li>Chat message (string)</li><li>Avatar_id</li> | <li>Player_id turn based on turn_order</li> | <li>User will be shown 3 actions: call, raise and fold.</li><li>If user calls, chip decreases by amount.</li><li>If user raises, select amount to raise and chip count decrease</li><li>If user folds, user turn will be skipped</li><li>There are 4 game phases: preflop, flop, turn and river</li><li>Each game phase progresses when the dealer button player_id selects “call”.</li><li>If the dealer button player_id selects “raise”, then the phase goes through each player again until the dealer button player_id selects “call”.</li><li>Center pile is updated with card_id on each game phase</li><li>Next player based on turn_order becomes current player</li><li>All users receive the updated game state (center pile, chip_count)</li><li>If player_id logs out of game, return to waiting lobby, and left_game becomes true.</li><li>If player (previously logged out) returns to game state, retrieve previous hand, card_id and turn_order.</li><li>If a player_id chip_count = 0, they will be removed from game_id</li><li>Player_id and avatar_id is visible to other player_id</li> | POST/game/:game_id/start (game_id, player_count) |
| User wins the round |<li>Player_id</li><li>Game_id</li><li>Card object</li><li>Card_id</li><li>Deck object</li><li>Hand object</li><li>Turn_order</li><li>Score</li><li>Chat message (string)</li><li>Avatar_id</li> | <li>User previously placed a bet</li><li>User has not folded</li><li>User wins the round when all other player_id has folded</li><li>User wins the round when game phase is at river, and user has the highest ranking hand</li><li>All pot_count goes into user’s chip_count</li><li>All card_ids are discarded and deck renews with a new set of 52 cards</li> | POST/game/:game_id/start (game_id, player_count) |
| User wins the game |<li>Player_id</li><li>Game_id</li><li>Card object</li><li>Card_id</li><li>Deck object</li><li>Hand object</li><li>Turn_order</li><li>Score</li><li>Avatar_id</li> | <li>Hand only has 1 card count previously</li><li>Playing card_id is legal move</li> | <li>Players are directed to game summary view, with scores for each player_id</li><li>Users can go back to waiting lobby or log out.</li><li>Player_id and avatar_id is visible to other player_id </li> | POST/game/:game_id/score (game_id, player_count, score)
| User loses the game |<li>Player_id</li><li>Game_id</li><li>Card object</li><li>Card_id</li><li>Deck object</li><li>Hand object</li><li>Turn_order</li><li>Score</li><li>Avatar_id</li> | <li>Chip_count is 0 for user either by:<li>Folding when user is small or big blind and chip_count falls to 0.<li>Bet all chip_count and loses the card ranking<li>Players are directed to game summary view, with ranking for each player_id<li>Users can go back to waiting lobby or log out.<li>Player_id and avatar_id is visible to other player_id | POST/game/:game_id/score (game_id, player_count) |
| User rejoins a game |<li>Player_id</li><li>Game_id</li><li>Card object</li><li>Card_id</li><li>Deck object</li><li>Hand object</li><li>Turn_order</li><li>Score</li><li>Avatar_id</li> | <li>Game still active = True</li><li>Chip_count not 0</li><li>If user rejoins an active game, must wait until round is over.</li><li>User will position will be last.</li> |POST/game/:game_id/score (game_id, player_count) |






